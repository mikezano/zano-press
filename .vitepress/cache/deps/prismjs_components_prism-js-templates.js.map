{
  "version": 3,
  "sources": ["../../../node_modules/prismjs/components/prism-js-templates.js"],
  "sourcesContent": ["(function (Prism) {\n\n\tvar templateString = Prism.languages.javascript['template-string'];\n\n\t// see the pattern in prism-javascript.js\n\tvar templateLiteralPattern = templateString.pattern.source;\n\tvar interpolationObject = templateString.inside['interpolation'];\n\tvar interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];\n\tvar interpolationPattern = interpolationObject.pattern.source;\n\n\n\t/**\n\t * Creates a new pattern to match a template string with a special tag.\n\t *\n\t * This will return `undefined` if there is no grammar with the given language id.\n\t *\n\t * @param {string} language The language id of the embedded language. E.g. `markdown`.\n\t * @param {string} tag The regex pattern to match the tag.\n\t * @returns {object | undefined}\n\t * @example\n\t * createTemplate('css', /\\bcss/.source);\n\t */\n\tfunction createTemplate(language, tag) {\n\t\tif (!Prism.languages[language]) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn {\n\t\t\tpattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'template-punctuation': {\n\t\t\t\t\tpattern: /^`|`$/,\n\t\t\t\t\talias: 'string'\n\t\t\t\t},\n\t\t\t\t'embedded-code': {\n\t\t\t\t\tpattern: /[\\s\\S]+/,\n\t\t\t\t\talias: language\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\n\tPrism.languages.javascript['template-string'] = [\n\t\t// styled-jsx:\n\t\t//   css`a { color: #25F; }`\n\t\t// styled-components:\n\t\t//   styled.h1`color: red;`\n\t\tcreateTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),\n\n\t\t// html`<p></p>`\n\t\t// div.innerHTML = `<p></p>`\n\t\tcreateTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),\n\n\t\t// svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n\t\tcreateTemplate('svg', /\\bsvg/.source),\n\n\t\t// md`# h1`, markdown`## h2`\n\t\tcreateTemplate('markdown', /\\b(?:markdown|md)/.source),\n\n\t\t// gql`...`, graphql`...`, graphql.experimental`...`\n\t\tcreateTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source),\n\n\t\t// sql`...`\n\t\tcreateTemplate('sql', /\\bsql/.source),\n\n\t\t// vanilla template string\n\t\ttemplateString\n\t].filter(Boolean);\n\n\n\t/**\n\t * Returns a specific placeholder literal for the given language.\n\t *\n\t * @param {number} counter\n\t * @param {string} language\n\t * @returns {string}\n\t */\n\tfunction getPlaceholder(counter, language) {\n\t\treturn '___' + language.toUpperCase() + '_' + counter + '___';\n\t}\n\n\t/**\n\t * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n\t *\n\t * @param {string} code\n\t * @param {any} grammar\n\t * @param {string} language\n\t * @returns {(string|Token)[]}\n\t */\n\tfunction tokenizeWithHooks(code, grammar, language) {\n\t\tvar env = {\n\t\t\tcode: code,\n\t\t\tgrammar: grammar,\n\t\t\tlanguage: language\n\t\t};\n\t\tPrism.hooks.run('before-tokenize', env);\n\t\tenv.tokens = Prism.tokenize(env.code, env.grammar);\n\t\tPrism.hooks.run('after-tokenize', env);\n\t\treturn env.tokens;\n\t}\n\n\t/**\n\t * Returns the token of the given JavaScript interpolation expression.\n\t *\n\t * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n\t * @returns {Token}\n\t */\n\tfunction tokenizeInterpolationExpression(expression) {\n\t\tvar tempGrammar = {};\n\t\ttempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;\n\n\t\t/** @type {Array} */\n\t\tvar tokens = Prism.tokenize(expression, tempGrammar);\n\t\tif (tokens.length === 3) {\n\t\t\t/**\n\t\t\t * The token array will look like this\n\t\t\t * [\n\t\t\t *     [\"interpolation-punctuation\", \"${\"]\n\t\t\t *     \"...\" // JavaScript expression of the interpolation\n\t\t\t *     [\"interpolation-punctuation\", \"}\"]\n\t\t\t * ]\n\t\t\t */\n\n\t\t\tvar args = [1, 1];\n\t\t\targs.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));\n\n\t\t\ttokens.splice.apply(tokens, args);\n\t\t}\n\n\t\treturn new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);\n\t}\n\n\t/**\n\t * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n\t *\n\t * This function has 3 phases:\n\t *\n\t * 1. Replace all JavaScript interpolation expression with a placeholder.\n\t *    The placeholder will have the syntax of a identify of the target language.\n\t * 2. Tokenize the code with placeholders.\n\t * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n\t *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n\t *    tokenized as two tokens by the grammar of the embedded language.\n\t *\n\t * @param {string} code\n\t * @param {object} grammar\n\t * @param {string} language\n\t * @returns {Token}\n\t */\n\tfunction tokenizeEmbedded(code, grammar, language) {\n\t\t// 1. First filter out all interpolations\n\n\t\t// because they might be escaped, we need a lookbehind, so we use Prism\n\t\t/** @type {(Token|string)[]} */\n\t\tvar _tokens = Prism.tokenize(code, {\n\t\t\t'interpolation': {\n\t\t\t\tpattern: RegExp(interpolationPattern),\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t});\n\n\t\t// replace all interpolations with a placeholder which is not in the code already\n\t\tvar placeholderCounter = 0;\n\t\t/** @type {Object<string, string>} */\n\t\tvar placeholderMap = {};\n\t\tvar embeddedCode = _tokens.map(function (token) {\n\t\t\tif (typeof token === 'string') {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\tvar interpolationExpression = token.content;\n\n\t\t\t\tvar placeholder;\n\t\t\t\twhile (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) { /* noop */ }\n\t\t\t\tplaceholderMap[placeholder] = interpolationExpression;\n\t\t\t\treturn placeholder;\n\t\t\t}\n\t\t}).join('');\n\n\n\t\t// 2. Tokenize the embedded code\n\n\t\tvar embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);\n\n\n\t\t// 3. Re-insert the interpolation\n\n\t\tvar placeholders = Object.keys(placeholderMap);\n\t\tplaceholderCounter = 0;\n\n\t\t/**\n\t\t *\n\t\t * @param {(Token|string)[]} tokens\n\t\t * @returns {void}\n\t\t */\n\t\tfunction walkTokens(tokens) {\n\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\tif (placeholderCounter >= placeholders.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar token = tokens[i];\n\n\t\t\t\tif (typeof token === 'string' || typeof token.content === 'string') {\n\t\t\t\t\tvar placeholder = placeholders[placeholderCounter];\n\t\t\t\t\tvar s = typeof token === 'string' ? token : /** @type {string} */ (token.content);\n\n\t\t\t\t\tvar index = s.indexOf(placeholder);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\t++placeholderCounter;\n\n\t\t\t\t\t\tvar before = s.substring(0, index);\n\t\t\t\t\t\tvar middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);\n\t\t\t\t\t\tvar after = s.substring(index + placeholder.length);\n\n\t\t\t\t\t\tvar replacement = [];\n\t\t\t\t\t\tif (before) {\n\t\t\t\t\t\t\treplacement.push(before);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treplacement.push(middle);\n\t\t\t\t\t\tif (after) {\n\t\t\t\t\t\t\tvar afterTokens = [after];\n\t\t\t\t\t\t\twalkTokens(afterTokens);\n\t\t\t\t\t\t\treplacement.push.apply(replacement, afterTokens);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\t\t\ttokens.splice.apply(tokens, [i, 1].concat(replacement));\n\t\t\t\t\t\t\ti += replacement.length - 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttoken.content = replacement;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar content = token.content;\n\t\t\t\t\tif (Array.isArray(content)) {\n\t\t\t\t\t\twalkTokens(content);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twalkTokens([content]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twalkTokens(embeddedTokens);\n\n\t\treturn new Prism.Token(language, embeddedTokens, 'language-' + language, code);\n\t}\n\n\t/**\n\t * The languages for which JS templating will handle tagged template literals.\n\t *\n\t * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n\t */\n\tvar supportedLanguages = {\n\t\t'javascript': true,\n\t\t'js': true,\n\t\t'typescript': true,\n\t\t'ts': true,\n\t\t'jsx': true,\n\t\t'tsx': true,\n\t};\n\tPrism.hooks.add('after-tokenize', function (env) {\n\t\tif (!(env.language in supportedLanguages)) {\n\t\t\treturn;\n\t\t}\n\n\t\t/**\n\t\t * Finds and tokenizes all template strings with an embedded languages.\n\t\t *\n\t\t * @param {(Token | string)[]} tokens\n\t\t * @returns {void}\n\t\t */\n\t\tfunction findTemplateStrings(tokens) {\n\t\t\tfor (var i = 0, l = tokens.length; i < l; i++) {\n\t\t\t\tvar token = tokens[i];\n\n\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar content = token.content;\n\t\t\t\tif (!Array.isArray(content)) {\n\t\t\t\t\tif (typeof content !== 'string') {\n\t\t\t\t\t\tfindTemplateStrings([content]);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (token.type === 'template-string') {\n\t\t\t\t\t/**\n\t\t\t\t\t * A JavaScript template-string token will look like this:\n\t\t\t\t\t *\n\t\t\t\t\t * [\"template-string\", [\n\t\t\t\t\t *     [\"template-punctuation\", \"`\"],\n\t\t\t\t\t *     (\n\t\t\t\t\t *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n\t\t\t\t\t *         or\n\t\t\t\t\t *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n\t\t\t\t\t *                                  It also has an alias which is the language of the embedded code.\n\t\t\t\t\t *     ),\n\t\t\t\t\t *     [\"template-punctuation\", \"`\"]\n\t\t\t\t\t * ]]\n\t\t\t\t\t */\n\n\t\t\t\t\tvar embedded = content[1];\n\t\t\t\t\tif (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {\n\t\t\t\t\t\t// get string content\n\t\t\t\t\t\tvar code = stringContent(embedded);\n\n\t\t\t\t\t\tvar alias = embedded.alias;\n\t\t\t\t\t\tvar language = Array.isArray(alias) ? alias[0] : alias;\n\n\t\t\t\t\t\tvar grammar = Prism.languages[language];\n\t\t\t\t\t\tif (!grammar) {\n\t\t\t\t\t\t\t// the embedded language isn't registered.\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontent[1] = tokenizeEmbedded(code, grammar, language);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfindTemplateStrings(content);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfindTemplateStrings(env.tokens);\n\t});\n\n\n\t/**\n\t * Returns the string content of a token or token stream.\n\t *\n\t * @param {string | Token | (string | Token)[]} value\n\t * @returns {string}\n\t */\n\tfunction stringContent(value) {\n\t\tif (typeof value === 'string') {\n\t\t\treturn value;\n\t\t} else if (Array.isArray(value)) {\n\t\t\treturn value.map(stringContent).join('');\n\t\t} else {\n\t\t\treturn stringContent(value.content);\n\t\t}\n\t}\n\n}(Prism));\n"],
  "mappings": "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",
  "names": ["Prism"]
}
